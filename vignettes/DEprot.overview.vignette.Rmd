---
title: "*DEprot*: an R-package for proteomics data normalization, imputationa and Differential Expression analyses"
date: "Last update: `r format(Sys.time(), '%d<sup>th</sup> %B, %Y')`"
author:
- name: "Sebastian Gregoricchio, Ph.D.<br>Nils Eickhoff, Ph.D."
  affiliation:
    - "Netherlands Cancer Institute, Oncogenomics division, Amsterdam - Netherlands"
  email: "sebastian.gregoricchio@nki.nl"
package: "*[DEprot](https://sebastian-gregoricchio.github.io/DEprot/)*"
output:
  prettydoc::html_pretty:
    highlight: github
    math: katex
    theme: cayman
    number_sections: true
    toc: true
    fig_caption: true
    fontsize: 11pt
vignette: >
  %\VignetteIndexEntry{DEprot: R-package to normalize, impute and perform differential analyses on LFQ-based proteomics data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = ">", dev = "svg",
                      warning = F, message = F, fig.align = "center",
                      rows.print=12)
#knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
#options(tibble.print_min = 4L, tibble.print_max = 4L)


# Load libraries required
require(DEprot)
```

![release](https://img.shields.io/github/v/release/sebastian-gregoricchio/DEprot)
![license](https://img.shields.io/badge/License-GPLv3-blue.svg)

[<img src="https://sebastian-gregoricchio.github.io/DEprot/DEprot_logo.svg" align="right" height = 150/>](https://sebastian-gregoricchio.github.io/DEprot)

----------------------------------------------------------

# **Introduction** {#intro}
<div style="text-align: justify">
The concept behind the *DEprot* (*D*ifferential *E*xpression *prot*eomics) is to provide a toolkit that allows for the normalization, imputation and analyses of the differential protein expression in proteomics data. The data are assumed to be LFQ (label-free quantitation) values.
</div>

## Citation
If you use this package, please cite:

<div class="warning" style='padding:2.5%; background-color:#c1eac4; color:#226a27; margin-left:5%; margin-right:5%; border-radius:15px;'>
<span>
<font size="-0.5">
<p style='margin-top:1em; text-align:left'> **Citation** </p>

<div style="margin-left:2%; margin-right:2%; text-align: justify">
"No publication associated yet *et al.*, *XYZ* (2123). <br>
*doi*: [XYZ/XYZ](https://doi.org/XYZ)
</div>
</font>

</span>
</div>

<br>

```{r citation, message=FALSE, warning=FALSE}
citation("DEprot")
```

<br>

---------------------------------------------------

# **Loading the data** {#loadingdata}
<div style="text-align: justify">
The package starting point is the building of a `DEprot` object. This class of objects is specific to this package and requires at least two elements:

* *counts table*: this must be a matrix in which the column names represent the samples while the rown ames identify the proteins. The values in the matrix are assumed to be LFQ (label-free quantitation) values, either in linear or log-transformed format.
* *metadata*: this must be a data.frame containing at least one column names `column.id` which values correspond to the column names of the *counts_table*. Any other additional column can be added (cell lines, treatment, condition, timing, etc) and used to define groups for differential and quality control ([PCA](#PCA) and [correlation](#correlation)) analyses.


In the next paragraph we will refer to a dataset (pre-loaded in `DEprot`), in which a breast cancer (BCa) cell line was cultured in either hormone-deprived media or in full media (FBS). If cultered in hormone-deprived condition, it was then treated for 6 hrs with either $\beta$-estradiol (E2) or vehicle (DMSO). 4 biological replicates have been analyzed. Hence, the datasets consists of 1 cell lines x 3 conditions x 4 replicates, for a total of 12 sample.\n
Proteins and samples have been "anonymized".
</div>

<br>

## Collect pre-loaded data {#preloadeddata}
<div style="text-align: justify">
The counts represent LFQ values in the log2 format and are not-imputed.
</div>

```{r read_metadata, eval=F}
# Metadata
data("sample.config", package = "DEprot")
sample.config
```
```{r print_metadata, echo=FALSE}
data("sample.config", package = "DEprot")
knitr::kable(sample.config, row.names = F, caption = "**Sample metadata table**")
```

<br>

```{r read_counts, eval=F}
# log2(LFQ) values (not imputed)
data("unimputed.counts", package = "DEprot")
head(unimputed.counts[,1:6])
```
```{r print_counts, echo=FALSE}
data("unimputed.counts", package = "DEprot")
knitr::kable(data.frame(head(unimputed.counts[,1:6])), row.names = T, caption = "**Unimputed log2(LFQ) values**")
```

<br>

## Build `DEprot` object {#deprotobject}
<div style="text-align: justify">
Now we will combine the the counts and metadata to create a `DEprot` object (hereafter defined as *dpo*).<br>
Notice that another import information is whether the data are log transformed, and if yes, which is the log base. Recommended transformation is the *log~2~(score + 1)*.

If data are pre-normalized and/or pre-imputed, it can be indicated with the corresponding parameters.<br>
If this is not the case, leave the parameters as `NA` (not `NULL`!).

Ultimately, if the metadata table does not contain a `column.id` column corresponding to the row names of the `counts_table`, it is possible to indicate the name of another column that should be assumed as to be the `column.id`.
</div>

```{r make_dpo}
dpo <- load.counts(counts = unimputed.counts,
                   metadata = sample.config,
                   log.base = 2,
                   imputation = NA,
                   normalization.method = NA,
                   column.id = "column.id")

dpo
```

<br>


<div style="text-align: justify">
This object is an S4-vector of class `DEprot`. The S4-vectors are containers of slots that can be accessed using the symbol `@` (e.g., `object@slot.id`.<br>The structure of an object of class `DEprot` (and `DEprot.analyses`) is the following:
</div>

| Slot                           | Description                                                                                               |
| -----------------------------: | :-------------------------------------------------------------------------------------------------------- |
| *raw.counts*                   | table containing the raw counts, if not available it will be `NULL`                                       |
| *norm.counts*                  | table containing the normalized counts, if not available it will be `NULL`                                |
| *imputed.counts*               | table containing the imputed counts, if not available it will be `NULL`                                   |
| *log.base*                     | a number indicating the base of the log used to transform the table, if not available it will be `NA`     |
| *log.transformed*              | logical value indicating whether the data are log-transformed or not                                      |
| *imputed*                      | logical value indicating whether the data are imputed or not                                              |
| *imputation*                   | discussed further in the [Imputation paragraph](#imputation)                                              |
| *normalized*                   | logical value indicating whether the data are normalized or not                                           |
| *normalization.method*         | a string indicating the type of normalization applied, if not available it will be `NA`                   |
| *boxplot.raw*                  | box+violin plot of the distribution of the LFQ intensities per sample obtained from the raw counts        |
| *boxplot.norm*                 | box+violin plot of the distribution of the LFQ intensities per sample obtained from the normalized counts |
| *boxplot.imputed*              | box+violin plot of the distribution of the LFQ intensities per sample obtained from the imputed counts    |
| *analyses.result.list*         | discussed further in the [Differential Expression analyses paragraph](#diffexp)                           |
| *contrasts*                    | discussed further in the [Differential Expression analyses paragraph](#diffexp)                           |
| *differential.analyses.params* | discussed further in the [Differential Expression analyses paragraph](#diffexp)                           |

<br>

## Rename sample columns {#rename}
<div style="text-align: justify">
As in our example, sometimes the columns of the counts are not the actual ID of the samples, but rather and identifier. However, it is possible to rename the counts column names indicating any column of the metadata table (having unique values). The original identifiers are stored in a new column (`old.column.id`) of the metadata.<br>
Notice that the renaming will applied to all counts table available.
</div>

```{r rename_samples}
dpo <- rename.samples(DEprot.object = dpo,
                      metadata.column = "sample.id")

get.metadata(dpo)
```

```{r display_rename_samples}
head(dpo@raw.counts[,1:6])
```

<br>


----------------------------------

# **Data normalization** {#normalization}
<div style="text-align: justify">
When a `DEprot` object is loaded, automatically a box/violin plot showing the distribution of the LFQ values per samples is generated.<br>
This representation is useful to estimate whether the data are normalized or not.
</div>

```{r display_boxplot_raw, fig.width=5, fig.cap='<div style="text-align: justify"> <font size="-0.5"> **Violin/boxplot LFQ intensities of unnormalized data** <br> Boxplots display the quantiles of the LFQ intensities, while red and blue dahsed lines correspond to maximum and minimum LFQ value for each sample. </font> </div> <br>'}
dpo@boxplot.raw
```


<div style="text-align: justify">
In this package we apply the Modified Balanced Quantile Normalization (MBQN) from the [`MBQN`](https://www.bioconductor.org/packages/release/bioc/html/MBQN.html) package and developed by [E.Brombacher *et al.* (*Proteomics*, 2020)](https://doi.org/10.1002/pmic.202000068). The modification balances the median (or mean) intensity of features (rows) which are rank invariant (RI) or nearly rank invariant (NRI) across samples (columns) before quantile normalization. This prevents an over-correction of the intensity profiles of RI and NRI features by classical quantile normalization and therefore supports the reduction of systematics in downstream analyses.
</div>


```{r normalize}
dpo <- normalize.counts(DEprot.object = dpo,
                        NRI.RI.ratio.threshold = 0.5,
                        balancing.function = "median")

dpo
```

```{r normalize2}
dpo@normalization.method
```

```{r normalize3}
head(dpo@raw.counts[,1:6])
```

<br>

<div style="text-align: justify">
Also in this case a box/violin plot with the corresponding normalized LFQ values per each sample is generated and stored in a vector slot.
</div>

```{r plot_norm, fig.width=8}
patchwork::wrap_plots(dpo@boxplot.raw, dpo@boxplot.norm, nrow = 1)
```

<br>

-----------------------------------------

# **Data imputation** {#imputation}
<div style="text-align: justify">
Often many `NA`/`NaN` values are present in the LFQ tables due to the techanical limitaions of the protein detection by Mass Spectrometry (MS) experiments.

Here we use the package [`missForest`](https://www.rdocumentation.org/packages/missForest/) package, developed by [DJ.Stekhoven & P.Buehlmann (*Bioinformatics*, 2012)](https://doi.org/10.1093/bioinformatics/btr597). This tool will impute the NaN and assign and estimated value. It also yields an out-of-bag (OOB) imputation error estimate (general, or per each sample). Moreover, it can be run parallel to save computation time (both examples reported here after).
</div>

```{r imputation_example, eval = F}
## Without parallelization
dpo <- impute.counts(DEprot.object = dpo,
                     max.iterations = 100,
                     variable.wise.OOBerror = T,
                     use.normalized.data = T)


## With parallelization
dpo <- impute.counts(DEprot.object = dpo,
                     max.iterations = 100,
                     variable.wise.OOBerror = T,
                     use.normalized.data = T,
                     cores = 10,
                     parallel.mode = "variables")

dpo

dpo@imputation$OOBerror

data.frame(dpo@imputation[-3])
```

```{r load_imputation, echo=FALSE}
dpo = readRDS(url("https://data.cyverse.org/dav-anon/iplant/home/sgregoricchio/DEprot/dpo.imputed.rds"))
dpo
```
```{r load_imputation2, echo=FALSE}
error = dpo@imputation$OOBerror
names(error) = colnames(dpo@imputed.counts)
error

knitr::kable(data.frame(dpo@imputation[-3]), row.names = F)
```

<br>

<div style="text-align: justify">
Also in this case a box/violin plot with the corresponding imputed LFQ values per each sample is generated and stored in a vector slot.
</div>

```{r plot_imputed, fig.width=9, fig.align='center'}
patchwork::wrap_plots(dpo@boxplot.raw, dpo@boxplot.norm, dpo@boxplot.imputed, nrow = 1)
```

<br>

-----------------------------------------

# **Sample similarities** {#pcacorrelation}
## Principal Component Analyses (PCA) {#pca}
<div style="text-align: justify">
PCA can be performed in order to perform a dimensional reduction and determine which factor explains the variability of the samples.<br>
`DEprot` includes function dedicated to this aim and specifically build to work with `DEprot` objects.

Notice that, even if the data are not log-transformed, `perform.PCA` will do it before performing the analyses.
</div>

### Compute PCs
```{r make_PCA, fig.width=8}
## Perform the analyses (DEprot.PCA object)
PCA <- perform.PCA(DEprot.object = dpo,
                   which.data = "imputed") # possible: raw, normalized, imputed
```

<div style="text-align: justify">
The `DEprot.PCA` object contains the following slots:
</div>

| Slot                 | Description                                                                                             |
| -------------------: | :------------------------------------------------------------------------------------------------------ |
| *PCA.metadata*       | metadata of the samples used in the PCA (subset of the original `DEprot@metadata`)                      |
| *sample.subset*      | vector containing the list of samples analyzed                                                          |
| *data.used*          | vector indicating the type of counts used (imputed, normalized, raw)                                    |
| *prcomp*             | object of class `prcomp` corresponding to the full PCA output                                           |
| *PCs*                | `data.frame` combining the PC scores and the metadata table, useful for replotting                      |
| *importance*         | statistical summary table for the PCA analyses per each PC                                              |
| *cumulative.PC.plot* | `ggplot` object corresponding to out put of `plot.PC.cumulative` for this object                        |


<br>

### Visualize PCAs
```{r run_cumulative}
## Plot cumulative variance of all PCs
#### equivalent to `PCA@cumulative.PC.plot`
plot.PC.cumulative(DEprot.PCA.object = PCA,
                   bar.color = "steelblue",
                   line.color = "navyblue")
```

```{r run_PCA}
## Plot PC scatters
PC_1.2 <-
  plot.PC.scatter(DEprot.PCA.object = PCA,
                  PC.x = 1,
                  PC.y = 2,
                  color.column = "condition",
                  shape.column = "replicate",
                  label.column = NULL,
                  plot.zero.lines = F) +
  geom_hline(yintercept = 0, color = "gray", linetype = "dashed") +
  theme(legend.position = "none")


PC_2.3 <-
  plot.PC.scatter(DEprot.PCA.object = PCA,
                  PC.x = 2,
                  PC.y = 3,
                  color.column = "condition",
                  shape.column = "replicate",
                  label.column = NULL,
                  plot.zero.lines = T)

patchwork::wrap_plots(PC_1.2, PC_2.3, nrow = 1)
```



### Analyze PCs on a sample subset
<div style="text-align: justify">
These analyses can also be performed for a subset of samples by indicated the sample names of interest.<br>
In the example below we will use only the sample in which the estrogen receptor is active (E2 and FBS conditions).
</div>

```{r make_PCA_subset, fig.width=8}
## Perform the analyses (DEprot.PCA object)
PCA.fbs.e2 <-
  perform.PCA(DEprot.object = dpo,
              sample.subset = dpo@metadata$column.id[grepl("E2|FBS",
                                                           dpo@metadata$column.id)],
              which.data = "imputed")


## Plot cumulative variance of all PCs
plot.PC.cumulative(DEprot.PCA.object = PCA.fbs.e2,
                   bar.color = "indianred",
                   line.color = "firebrick4",
                   title = "**Only ERa active**")
```

```{r make_PCA_scatters_subset, fig.width=8}
## Plot PC scatters
PC.fbs.e2_1.2 <-
  plot.PC.scatter(DEprot.PCA.object = PCA.fbs.e2,
                  PC.x = 1,
                  PC.y = 2,
                  color.column = "condition",
                  shape.column = "replicate",
                  label.column = NULL,
                  plot.zero.lines = F) +
  geom_hline(yintercept = 0, color = "gray", linetype = "dashed") +
  theme(legend.position = "none")
  
  
PC.fbs.e2_2.3 <-
  plot.PC.scatter(DEprot.PCA.object = PCA.fbs.e2,
                  PC.x = 2,
                  PC.y = 3,
                  color.column = "condition",
                  shape.column = "replicate",
                  label.column = NULL,
                  plot.zero.lines = T)

patchwork::wrap_plots(PC.fbs.e2_1.2, PC.fbs.e2_2.3, nrow = 1)
```


<br>


## Correlations {#correlataion}
<div style="text-align: justify">
Another method to define the sample clustering/groups, is the overall correlation between the samples.<br>
Hierarchical clustering is performed using the `1 - correlation` values, since the hierarchical clustering algorithm is based on dissimilarities while the correlations are an index of similarity.
</div>


```{r make_correlation_all, fig.width=9}
corr.all.samples <-
  plot.correlation.heatmap(DEprot.object = dpo,
                           which.data = "imputed",
                           palette = viridis::mako(n = 10, direction = -1, begin = 0.25),
                           correlation.scale.limits = c(0.9,1),
                           correlation.method = "pearson",
                           plot.subtitle = "All samples",
                           display.values = TRUE)
corr.all.samples
```


<div style="text-align: justify">
Also in this case the sample correlation can be computed for a subset of samples as shown before for the [PCAs](#pca).
</div>

```{r make_correlation_subset}
corr.ERa.active <-
  plot.correlation.heatmap(DEprot.object = dpo,
                           which.data = "imputed",
                           sample.subset = dpo@metadata$column.id[grepl("E2|FBS",
                                                                        dpo@metadata$column.id)],
                           palette = viridis::magma(n = 10, direction = -1, begin = 0.25),
                           correlation.scale.limits = c(0.9,1),
                           correlation.method = "pearson",
                           plot.subtitle = "Only ERa active",
                           clustering.method = "complete",
                           display.values = TRUE)

corr.ERa.active
```



<div style="text-align: justify">
The `DEprot.correlation` correlation object contains the following slots:
</div>

| Slot               | Description                                                                                             |
| -----------------: | :------------------------------------------------------------------------------------------------------ |
| *heatmap*          | `ggplot` object corresponding to the correlation heatmap                                                |
| *corr.metadata*    | metadata of the samples used in the correlation (subset of the original `DEprot@metadata`)              |
| *sample.subset*    | vector containing the list of samples analyzed                                                          |
| *data.used*        | vector indicating the type of counts used (imputed, normalized, raw)                                    |
| *corr.matrix*      | the correlation matrix on which the heatmap is base on                                                  |
| *distance*         | object of class `dist` corresponding to the output of `as.dist(1 - correlation.matrix)`                 |
| *cluster*          | `hclust` object generated by `hclust(d = as.dist(1 - correlation.matrix), method = clustering.method)`  |


<br>

-----------------------------------------

# **Differential Expression (DE) analyses** {#diffexp}
<div style="text-align: justify">
Differential expression analyse between two conditions can be performed using the function `diff.analyses`.<br>
The conditions can be compared two-by-two (individual t-/wilcoxon tests). Is is sufficient to provide a list of 3-elements vectors. The latter, should indicate any column of the metadata table (grouping factor) and two values (groups) to compare within this column. The first variable will be numerator and the second the denominator of the fold change: `c("group.column", "condition.A", "condition.B")`, FoldChange = group A/B.

When a replicate column is available, it is possible to run the analyses in *paired* mode. It is sufficient to indicate the column from the metadata table that corresponds to the replicate identifiers (in our example `replicate`) and set `paired.test = TRUE`. For each contrast it will be verified that replicate identifiers are not repeated within a group and, that replicate number and identifiers coincide between the two groups. By the default analyses ignore the replicates.

In the following example we will compare *6h.10nM.E2* vs *6h.DMSO*, and *6h.10nM.E2* vs *FBS*. Both paired and unpaired examples are shown, but further analyses are based on the paired results.
</div>

```{r compute_diff_exp_examples, eval=F}
## Unpaired test
dpo_analyses <- diff.analyses(DEprot.object = dpo,
                              contrast.list = list(c("condition", "6h.10nM.E2", "6h.DMSO"),
                                                   c("condition", "6h.10nM.E2", "FBS")),
                              linear.FC.th = 2,
                              padj.th = 0.05,
                              padj.method = "bonferroni",
                              stat.test = "t.test",
                              which.data = "imputed")

## Paired test
dpo_analyses <- diff.analyses(DEprot.object = dpo,
                              contrast.list = list(c("condition", "6h.10nM.E2", "6h.DMSO"),
                                                   c("condition", "6h.10nM.E2", "FBS")),
                              replicate.column = "replicate",
                              paired.test = TRUE,
                              linear.FC.th = 2,
                              padj.th = 0.05,
                              padj.method = "bonferroni",
                              stat.test = "t.test",
                              which.data = "imputed")

dpo_analyses
```

```{r compute_diff_exp_paired, echo=FALSE}
## Paired test
dpo_analyses <- diff.analyses(DEprot.object = dpo,
                              contrast.list = list(c("condition", "6h.10nM.E2", "6h.DMSO"),
                                                   c("condition", "6h.10nM.E2", "FBS")),
                              replicate.column = "replicate",
                              paired.test = TRUE,
                              linear.FC.th = 2,
                              padj.th = 0.05,
                              padj.method = "bonferroni",
                              stat.test = "t.test",
                              which.data = "imputed")

dpo_analyses
```

The summary can be collected by using the generic function `summary`:

```{r analyses_summary, eval=F}
diff.analyses_summary = summary(dpo)
```

<br>


## DE results
The output will be a `DEprot.analyses` object. This class is similar to the base `DEprot` one, however 3 slots are now available:

* *contrasts*: corresponds to the list used to define the contrasts, but includes also the IDs of the counts matrix belonging to each subgroup and whether the statistical test was performed in *paired* mode.
* *differential.analyses.params*: a list containing the core parameters used for the differential expression analyses.
* *analyses.result.list*: a list with an element for each contrast including all the results of the differential analyses (see below for details).

The `analyses.result.list`, for each contrast, stores a list with the following elements:

| Element        | Description                                                                                                        |
| -------------: | :----------------------------------------------------------------------------------------------------------------- |
| *results*      | a data.frame containing the results of the analyses; includes average expression of each group, basemean, foldchange, pavalue and p.adj, differential.status |
| *n.diff*       | a summary table showing the number of proteins in each differential expression status (up/down/unresponsive, null) |
| *PCA.data*     | output of `perform.PCA` for the subset of samples analyzed in a specific contrast                                  |
| *PCA.plots*    | combination of 3 plots: scatter PC1-vs-PC2, scatter PC2-vs-PC3, and cumulative bar plot                            |
| *correlations* | combination of Pearson and Spearman correlation heatmaps (obtained by `plot.correlation.heatmap`) for the subset of samples analyzed in a specific contrast |
| *volcano*      | volcano plot showing the log2(FoldChange) x -log10(p.adjusted) of differential expression results; it can be regenerated using `plot.volcano` |
| *MA.plot*      | MA-plot showing the log2(basemean) x log2(FoldChange) of differential expression results; it can be regenerated using `plot.MA` |

<br>

### DE table
The table with the results of the differential analyses can be retrieved directly from the list in the `DEprot.analyses` object (`dpo_analyses@analyses.result.list$contrast.id$results`) or using the `get.results` function.

```{r get_results, eval = F}
## Direct access
results = dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$results

## Function
results = get.results(dpo_analyses, contrast = 1)

head(results)
```

```{r get_results2, echo=FALSE}
knitr::kable(get.results(dpo_analyses, contrast = 1)[1:6,], row.names = F)
```

<br>

### PCA and correlation within the comparison
The `DEprot.analyses` object includes PCA and correlation analyses of the samples involved in the contrast.

```{r DE_PCA_scatters, fig.width=8, eval=F}
dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$PCA.plots
```

```{r DE_PCA_scatters_replotting, echo=FALSE, fig.width=8}
scatter_PC12 = plot.PC.scatter(dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$PCA.data, 1,2, color.column = "condition") + theme(legend.position = "none")
scatter_PC23 = plot.PC.scatter(dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$PCA.data, 2,3, color.column = "condition")
cumulative = plot.PC.cumulative(dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$PCA.data)

scatters = cowplot::plot_grid(scatter_PC12, scatter_PC23, nrow = 1, align = "hv", axis = "tblr")
cowplot::plot_grid(scatters, cumulative, ncol = 1, axis = "tblr")
```


```{r DE_correlations, fig.width=10}
dpo_analyses@analyses.result.list$condition_6h.10nM.E2.vs.6h.DMSO$correlations
```

<br>

### Visualize DE analyses
Differential expressed proteins can be visualized as either a volcano plot or an MA-plot.<br>
Both these plots are available in the `dpo_analyses@analyses.result.list$contrast.id` list, but can also be generated using the functions `plot.volcano` and `plot.MA`.

Of not, if `use.uncorrected.pvalue = TRUE`, the normal p-value will be used instead of the p.adjusted. In this case the FoldChange and p-value thresholds are collected from the `DEprot.analyses` object and reapplied to compute the new differential status of the proteins.

```{r DE_volcano_MA, fig.width=9}
volcano = plot.volcano(dpo_analyses, contrast = 1, use.uncorrected.pvalue = TRUE)
MAplot = plot.MA(dpo_analyses, contrast = 1, use.uncorrected.pvalue = TRUE)

patchwork::wrap_plots(volcano, MAplot)
```

<br>

-----------------
# **Package information** {#info}
## Documentation
<div style="text-align: justify">
With the package a detailed [PDF manual](https://sebastian-gregoricchio.github.io/DEprot/DEprot_manual.pdf) with details for each function and respective parameters is available.

The R-package have been published on [GitHub](https://github.com/sebastian-gregoricchio/DEprot) and a [git-pages website](https://sebastian-gregoricchio.github.io/DEprot) is available as well. At both these sites it is possible to find the installation procedure, required dependencies, and the links for changeLog, manual and vignette.
</div>

<br>

## Package history and releases
<div style="text-align: justify">
A list of all releases and respective description of changes applied could be found [here](https://sebastian-gregoricchio.github.io/DEprot/NEWS).
</div>


<br>

## Contact
<div style="text-align: justify">
For any suggestion, bug fixing, commentary please contact:

[![contributors](https://badges.pufler.dev/contributors/sebastian-gregoricchio/DEprot?size=50&padding=5&bots=true)](https://sebastian-gregoricchio.github.io/) Sebastian Gregoricchio  [sebastian.gregoricchio@nki.nl](mailto:sebastian.gregoricchio@gmail.com)
</div>

<br>

## License
<div style="text-align: justify">
This package is under a [GNU General Public License (version 3)](https://sebastian-gregoricchio.github.io/DEprot/LICENSE.md/LICENSE).
</div>

<br>
