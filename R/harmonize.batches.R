#' @title harmonize.batches
#'
#' @description The function uses the package \href{https://www.bioconductor.org/packages/release/bioc/html/HarmonizR.html}{\code{HarmonizR}} to correct batch effects in a combined table of multiple experiments.
#'
#' @param DEprot.object A \code{DEprot object}, as generated by \link{load.counts}. Notice that this function works only with "normalized".
#' @param batch.column String indicating the name of a column from the metadata table in which are stored the replicate IDs. This column is used only if \code{paired.test = TRUE}. Default: \code{NULL}.
#' @param cores Numeric value indicating the number of cores to use for the batch correction. Default: \code{1}.
#'
#' @export harmonize.batches

harmonize.batches =
  function(DEprot.object,
           batch.column = "batch",
           cores = 1) {

    ### Packages
    require(dplyr)
    require(ggplot2)

    if (!requireNamespace("HarmonizR", quietly = TRUE)) {
      warning("The 'HarmonizR' (Bioconductor) package must be installed to use this function.")
      #Either exit or do something without rgl
      return(NULL)
    } else {
      require(HarmonizR)
    }

    #------------------------------------------------------------------


    ### check object and extract metadata table
    if (!("DEprot" %in% class(DEprot.object))) {
      warning("The input must be an object of class 'DEprot'.")
      return(DEprot.object)
    }
    meta.tb = DEprot.object@metadata


    ### check if raw un-imputed data are available
    if (is.null(DEprot.object@raw.counts)) {
      warning(paste0("The 'harmonize.batches' function requires that the data are loaded as 'raw'\n",
                     #"Combine tables of intra-batch normalized data and then use 'harmonize.batches' to correct the signal among batches."
                     ))
    }


    ### Check 'batch.column' presence and eventually the paired.test variable
    if (!is.null(batch.column[[1]])) {
      if (!(batch.column %in% colnames(meta.tb))) {
        warning("The 'batch.column' is not present in the metadata of the object.")
        return(DEprot.object)
      } else {
        meta.tb[,batch.column[[1]]] = as.character(meta.tb[,batch.column[[1]]])
      }
    }

    ### Create description file for Harmonizer
    des = data.frame(ID = meta.tb$column.id,
                     sample = meta.tb$column.id,
                     batch = as.numeric(factor(meta.tb[,batch.column[[1]]], labels = c(1:length(unique(meta.tb[,batch.column[[1]]]))))))


    ### Harmonize batches
    batch.corrected.counts = HarmonizR::harmonizR(data_as_input = data.frame(DEprot.object@raw.counts),
                                                  description_as_input = des,
                                                  cores = cores)


    ### Update DEprot object
    batch.corrected.DEprot = DEprot.object

    batch.corrected.DEprot@norm.counts = as.matrix(batch.corrected.counts)
    batch.corrected.DEprot@normalized = T
    batch.corrected.DEprot@normalization.method = "HarmonizR"

    batch.corrected.DEprot@boxplot.norm =
      DEprot::plot.counts(DEprot.object = batch.corrected.DEprot,
                          which.data = "normalized",
                          violin.color = "purple",
                          convert.log2 = T) +
      ggtitle("**Normalized**",
              subtitle = "*HarmonizR*") +
      theme(plot.subtitle = ggtext::element_markdown(hjust = 0.5))


    ## Return corrected DEprot object
    return(batch.corrected.DEprot)

  } # END function
