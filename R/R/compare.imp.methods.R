#' @title compare.imp.methods
#'
#' @description Function that computes the Root Mean Squared Error (RMSE) for all the 4 possibile imputation algorithms: \href{https://www.rdocumentation.org/packages/missForest/}{missForest}, \href{https://rdrr.io/cran/VIM/man/kNN.html}{kNN}, \href{https://rdrr.io/bioc/pcaMethods/man/llsImpute.html}{LLS}, \href{https://rdrr.io/bioc/pcaMethods/man/pca.html}{SVD}.
#' A new dataset containing only proteins with known values is created, a certain percentage of NAs is then manually introduced. This percentage is equivalent to the precentage of missing values in the original data set. At the end the imputed values in the new data set are compared with the measured (expected) ones.
#'
#' @param DEprot.object A \code{DEprot object}, as generated by \link{load.counts} or \link{load.counts2}.
#' @param percentage.test Numeric value between 0 (excluded) and 100 indicating the percentage of proteins to use for the test dataset. Default: \code{30}.
#' @param use.normalized.data Logical value indicating whether the imputation should be performed based on the rationalized data. Default: \code{TRUE}.
#' @param overwrite.imputation Logical value to indicate whether, in the case already available, the table of imputed counts should be overwritten. Default: \code{FALSE}.
#' @param missForest.max.iterations Max number of iterations for the missForest algorithm. Default: \code{100}.
#' @param missForest.variable.wise.OOBerror Logical value to define whether the OOB error is returned for each variable separately. Default: \code{TRUE}.
#' @param missForest.cores Number of cores used to run the missForest algorithm. If \code{missForest.cores} is 1 (or lower), the imputation will be run in parallel. Two modes are possible and can be defined by the parameter \code{missForest.parallel.mode}. Default: \code{1}.
#' @param missForest.parallel.mode Define the mode to use for the parallelization, ignored when \code{cores} is more than 1. One among: 'variables', 'forests'. Default: \code{"variables"}. See also the documentation of the \href{https://www.rdocumentation.org/packages/missForest/versions/1.5/topics/missForest}{missForest function}.
#' @param verbose Logical valued indicating whether processing messages should be printed. Default: \code{FALSE}.
#' @param seed Numeric value indicating the seed to use for the randomization. Default: \code{NULL}, automatically generated (saved in the \code{seed} slot in the final object).
#'
#' @seealso \href{https://www.rdocumentation.org/packages/missForest/}{missForest package}, href{https://cran.r-project.org/web/packages/VIM/index.html}{VIM package}, href{https://www.bioconductor.org/packages/release/bioc/html/pcaMethods.html}{pcaMethods package}.
#'
#' @return A \code{DEprot.RMSE} object.
#'
#' @export compare.imp.methods

compare.imp.methods =
  function(DEprot.object,
           percentage.test = 30,
           use.normalized.data = TRUE,
           missForest.max.iterations = 100,
           missForest.variable.wise.OOBerror = TRUE,
           missForest.cores = 1,
           missForest.parallel.mode = "variables",
           seed = NULL,
           verbose = FALSE) {

    ### check object
    if (!("DEprot" %in% class(DEprot.object))) {
      warning("The input must be an object of class 'DEprot'.")
      return(DEprot.object)
    }

    ### check percentage value
    if (percentage.test <= 0) {
      warning("The `percentage.test` must be a number above 0.")
      return(DEprot.object)
    } else if (percentage.test > 100) {
      percentage.test = 100
      message("The `percentage.test` must be a number at maximum equal to 100.\
              The `percentage.test` value has been set to 100.")
    }


    ### Check if normalized data are available
    if (use.normalized.data == T) {
      if (is.null(DEprot.object@norm.counts)) {
        warning(paste0("You asked to use normalized data for the imputation, but normalized data are not available.\n",
                       "To perform imputation on raw data, set 'use.normalized.data = FALSE'."))
        return(DEprot.object)
      } else {
        cnt = DEprot.object@norm.counts
      }
    } else {
      cnt = DEprot.object@raw.counts
    }


    ### Set seed
    if (is.null(seed)) {
      seed = runif(n = 1, min = 0, max = 2^31-1)
      set.seed(I(seed))
    } else {
      set.seed(I(seed))
    }


    ### Number of proteins for test
    n.test.prot = min(c(ceiling(nrow(cnt) * (percentage.test/100)), nrow(cnt)))

    ### Get the counts of only known data
    cnt.known = cnt[rowSums(is.na(cnt)) == 0,]

    ### Get the sample data set
    if (n.test.prot < nrow(cnt.known)) {
      sample.data = cnt.known[sample(x = 1:nrow(cnt.known), size = n.test.prot),]
    } else {
      message("The number of usable proteins is lower than the number of proteins requested.")
      sample.data = cnt.known
    }



    ### Introduce artificial NAs
    # Estimate fraction of missing values in the original data
    fraction.missing = sum(is.na(cnt)) / (ncol(cnt) * nrow(cnt))

    # Define how many new NAs are needed in the sample.data
    n.na = floor((ncol(sample.data) * nrow(sample.data)) * fraction.missing)

    # Define the combination of row x column that will define the cells in which the NAs will be introduced
    cells.na = list(rows = sample(1:nrow(sample.data), size = n.na, replace = T),
                    cols = sample(1:ncol(sample.data), size = n.na, replace = T))

    # Add NAs to the sample.data table
    sample.data.na = sample.data
    for (i in 1:n.na) {sample.data.na[cells.na$rows[i], cells.na$cols[i]] = NA}




    ### Generate a new dpo object with the reduced and artificially modified data
    dpo.na = DEprot::load.counts2(counts = sample.data.na,
                                  metadata = DEprot.object@metadata,
                                  data.type = "normalized",
                                  log.base = DEprot.object@log.base)


    ### Run all the imputations on the sample.data
    if (isTRUE(verbose)) {message("Performing `missForest` imputation...")}
    dpo.na_missForest = DEprot::impute.counts(DEprot.object = dpo.na,
                                              method = "missForest",
                                              missForest.max.iterations = missForest.max.iterations,
                                              missForest.variable.wise.OOBerror = missForest.variable.wise.OOBerror,
                                              missForest.cores = missForest.cores,
                                              missForest.parallel.mode = missForest.parallel.mode,
                                              verbose = verbose)


    if (isTRUE(verbose)) {message("Performing `kNN` imputation...")}
    dpo.na_kNN = DEprot::impute.counts(DEprot.object = dpo.na,
                                       method = "kNN",
                                       verbose = verbose)

    if (isTRUE(verbose)) {message("Performing `LLS` imputation...")}
    dpo.na_LLS = DEprot::impute.counts(DEprot.object = dpo.na,
                                       method = "LLS",
                                       verbose = verbose)

    if (isTRUE(verbose)) {message("Performing `SVD` imputation...")}
    dpo.na_SVD = DEprot::impute.counts(DEprot.object = dpo.na,
                                       method = "SVD",
                                       verbose = verbose)





    ### Computation of the Root Mean Squared Error (RMSE)
    # RMSE = sqrt[ Σ(Pi – Oi)² / n ]
    # where: Pi is the predicted/imputed value for the i-th observation; Oi is the observed/real value for the i-th observation; n is the number of observations.
    # 1. Calculate the residuals: For each data point, subtract the predicted value from the observed value. This difference is the residual.
    # 2. Square the residuals: Square each of the residuals calculated in the previous step.
    # 3. Calculate the mean of the squared residuals: Sum all the squared residuals and divide by the number of data points (n). This is the Mean Squared Error (MSE).
    # 4. Take the square root: Finally, calculate the square root of the MSE. This result is the RMSE.

    # Collect imputed tables
    missForest = dpo.na_missForest@imputed.counts
    kNN = dpo.na_kNN@imputed.counts
    LLS = dpo.na_LLS@imputed.counts
    SVD = dpo.na_SVD@imputed.counts

    imp.tables = list(missForest = missForest,
                      kNN = kNN,
                      LLS = LLS,
                      SVD = SVD)

    # get the 'expected' values
    exp.values = c()
    for (i in 1:n.na) {exp.values[i] = sample.data[cells.na$rows[i], cells.na$cols[i]]}

    exp.tb = data.frame(row.idx = cells.na$rows,
                        col.idx = cells.na$cols,
                        row.id = rownames(sample.data)[cells.na$rows],
                        col.id = rownames(sample.data)[cells.na$cols],
                        expected.values = exp.values)


    # compute RMSE scores
    RMSE.tables = list()
    RMSE.scores = c()

    for (i in 1:length(imp.tables)) {
      imputed.values = c()
      for (k in 1:n.na) {imputed.values[k] = imp.tables[[i]][cells.na$rows[k], cells.na$cols[k]]}

      RMSE.tables[[i]] =
        exp.tb %>%
        dplyr::mutate(imputation.method = names(imp.tables)[i],
                      imputed.values = imputed.values) %>%
        dplyr::mutate(residuals = imputed.values - expected.values) %>%
        dplyr::mutate(sq.residuals = residuals ^ 2)

      MSE_mean.sq.residuals = mean(sqrt(RMSE.tables[[i]]$sq.residuals), na.rm = T)
      RMSE.scores[i] = sqrt(MSE_mean.sq.residuals)
    }

    names(RMSE.tables) = names(imp.tables)
    names(RMSE.scores) = names(imp.tables)




    ### Plot correlations
    correlations = list()

    for (i in 1:length(RMSE.tables)) {
      correlations[[i]] =
        ggplot(data = RMSE.tables[[i]],
               aes(x = expected.values,
                   y = imputed.values)) +
        geom_abline(slope = 1, intercept = 0, linetype = "dotted", color = "gray50") +
        geom_point(aes(fill = residuals), color = "black", size = 2.5, alpha = 0.75, shape = 21) +
        geom_smooth(formula = y ~ x, method = "glm", fill = "steelblue") +
        ggpubr::stat_cor(mapping = aes(group = 1)) +
        scale_fill_gradient2(low = "firebrick",
                             mid = "white",
                             high = "steelblue4",
                             midpoint = 0,
                             name = "Residual",
                             limits = c(-1,1)*max(abs(RMSE.tables[[i]]$residuals))) +
        ggtitle(paste0("**",names(RMSE.tables)[i],"**")) +
        ylab("Imputed values") +
        xlab("Expected values") +
        annotate(geom = "text", x = +Inf, y = -Inf, label = paste0("RMSE = ", round(RMSE.scores[i],3)), hjust = 1.25, vjust = -1.5) +
        ggpubr::theme_pubr(legend = "right") +
        theme(plot.title = ggtext::element_markdown(hjust = 0.5),
              aspect.ratio = 1)
    }




    ### Make and return DEprot.RMSE object
    DEprot.RMSE.object =
      new(Class = "DEprot.RMSE",
          original.DEprot.object = DEprot.object,
          percentage.test = percentage.test,
          seed = seed,
          fraction.missing.values = fraction.missing,
          test.dataset = sample.data,
          imputated.objects = list(missForest = dpo.na_missForest,
                                   kNN = dpo.na_kNN,
                                   LLS = dpo.na_LLS,
                                   SVD = dpo.na_SVD),
          RMSE.tables = RMSE.tables,
          RMSE.scores = RMSE.scores,
          correlation.plots = correlations)

    return(DEprot.RMSE.object)

  } # END function
