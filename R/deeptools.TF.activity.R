# DEEPTOOLS ATAC aggregates analyses

analyze.deeptools.TF.activity =
  function(sample.groups,  # sample.ID | group
           matrix.dir,
           matrix.suffix = "_single.base.scores_per.region.gz",
           TF.subset = NULL,
           missing.data.as.zero = TRUE,
           comparison.list = NULL,
           group.colors = NULL,
           group.order = NULL,
           scale.zero.one = TRUE,
           AUC_sector_fraction = 0.25,
           p.adjust.method = "BH",
           p.label.format = "p.format", #or p.signif
           paired.stats = T,
           #FC.linear.threshold = 2,
           ratio.FC.linear.threshold = 2,
           p.adj.threshold = 0.05,
           add.label.diffTF = TRUE,
           max.overlap.labels = 10,
           
           
           
           
           ignore.statistics = FALSE,
           compute.confidence.interval = T,
           confidence.level = 0.9,
           foldChange.threshold = 1.3,
           percentage.top.hits = 5,
           basemean.AUC.threshold = 0.1,
           heatmap.cluster.rows = TRUE,
           heatmap.cluster.columns = TRUE,
           heatmap.scaling.mode = "row", # row, column, none
           heatmap.palette = "Spectral",
           heatmap.nColors = 101,
           heatmap.showRowNames = FALSE,
           heatmap.showColNames = TRUE,
           heatmap.n.row.kmeans = NA,
           heatmap.border.color = NA,
           error.transparency = 0.15,
           MAplot.show.names = TRUE,
           TF_whitelist = NULL,
           TF_blacklist = NULL) {
    
    #############################################
    # Load libraries
    require(dplyr)
    require(plyr)
    require(ggplot2)
    
    #############################################
    
    
    # Clean input data
    matrix.dir = gsub("/$", "", matrix.dir)
    
    colnames(sample.groups)[1:2] = c("sample.ID", "group")
    if (is.null(group.order)) {levels = unique(sample.groups$group)} else {levels = group.order}
    sample.groups =
      sample.groups %>%
      dplyr::mutate(group = factor(group, levels = levels)) %>%
      dplyr::arrange(group, sample.ID)
    
    
    # get the list of tables and corresponding TF name
    score_file_list = list.files(path = matrix.dir,
                                 pattern = matrix.suffix,
                                 full.names = T)
    
    TF_list = gsub(paste0(matrix.dir,"/|",matrix.suffix), "", score_file_list)
    if (!is.null(TF.subset)) {
      TF_list = TF_list[TF_list %in% TF.subset]
    }
    if (length(TF_list) < 1) {return("The TF subsetting retunred any TF 'to analyse'.\nPlease define another sub set or set the parameter to NULL to run the analyses on all the TFs available in the folder.")}

    
    
    # Define colors for groups in footprint
    if (is.null(group.colors)) {
      group.colors = rainbow(length(levels))
    }
    
    
    # Define comparisons if not user-defined
    if (is.null(comparison.list)) {
      combos = combn(x = unique(sample.groups$group), m = 2)
      comparison.list = list()
      for (i in 1:ncol(combos)) {
        comparison.list[[i]] = c(as.vector(combos[1,i]), as.vector(combos[2,i]))
      }
    }
    
    
    
    #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    read.deeptools.matrix = 
      function(matrix.file,
               missing.data.as.zero = TRUE,
               sample.names = NULL,
               region.names = NULL) {

        # Import/read the matrix.gz file
        if (class(matrix.file) == "character" & length(matrix.file) == 1) {
          m = Rseb::read.computeMatrix.file(matrix.file)
          metadata = m$metadata
          matrix.data = m$matrix.data
        } else if (class(matrix.file) == "list" & length(matrix.file) == 3 & unique(names(matrix.file) == c("metadata", "matrix.data", "original.file.path"))) {
          metadata = matrix.file$metadata
          matrix.data = matrix.file$matrix.data
        } else {
          return(warning("The 'matrix.file' must be a single string indicating a full path to a matrix.gz file generated by deepTools/computeMatrix or by Rseb::computeMatrix.deeptools(), or a list generated by the function Rseb::read.computeMatrix.file."))
        }
        
        # Generate metadata variables
        sample_start_column = as.numeric(as.vector(stringr::str_split(string = dplyr::filter(.data = metadata, parameters == "sample_boundaries")$values, pattern = ",")[[1]]))
        sample_names = as.vector(stringr::str_split(string = dplyr::filter(.data = metadata, parameters == "sample_labels")$values, pattern = ",")[[1]])
        
        group_start_row = as.numeric(as.vector(stringr::str_split(string = dplyr::filter(.data = metadata, parameters == "group_boundaries")$values, pattern = ",")[[1]]))
        group_names = as.vector(stringr::str_split(string = dplyr::filter(.data = metadata, parameters == "group_labels")$values, pattern = ",")[[1]])
        
        ##############################################################################
        # Get the number at which the matrix data starts (after 'chr' 'start' 'end' 'strand' etc.)
        number.info.columns = ncol(matrix.data) - sample_start_column[length(sample_start_column)]
        
        # Remove NaN values and substitute them with 0 if missing.data.as.zero = TRUE or NA if FALSE
        missing.data.as.zero.automatic = as.logical(toupper(dplyr::filter(.data = metadata, parameters == "missing_data_as_zero")$values))
        
        if (is.null(missing.data.as.zero) | !is.logical(missing.data.as.zero)) {missing.data.as.zero = missing.data.as.zero.automatic}
        
        is.nan.data.frame = function(data.frame) do.call(cbind, lapply(data.frame, is.nan))
        
        matrix.data[is.nan(matrix.data)] = ifelse(test = missing.data.as.zero,
                                                  yes = 0,
                                                  no = NA)
        
        #message(ifelse(test = missing.data.as.zero,
        #               yes = "Missing data have been converted to 0 since the parameter 'missing.data.as.zero' is TRUE.",
        #               no = "Missing data have been converted to NA since the parameter 'missing.data.as.zero' is FALSE. \nNA values will be excluded from the statistical computations."))
        
        ##############################################################################
        # Generate a list with a table per sample
        samples.table.list = list()
        
        # Change sample and group names by custom ones
        if (!is.null(sample.names)) {
          if (length(unique(sample.names)) == length(sample_names)) {
            sample_names = sample.names
          } else {message("Default sample.names have been used because custom valus are not unique and/or incomplete")}
        }
        
        if (!is.null(region.names)) {
          if (length(unique(region.names)) == length(group_names)) {
            group_names = region.names
          } else {message("Default region.names have been used because custom valus are not unique and/or incomplete")}
        }
        
        for (i in 1:length(sample_names)) {
          # define the limits of the sample keeping the first lines
          start.col = sample_start_column[i] + number.info.columns + 1
          end.col = sample_start_column[i+1] + number.info.columns
          
          sample.table =
            matrix.data %>%
            dplyr::select(c(1:number.info.columns, start.col:end.col)) %>%
            # adding a column with the groups names
            dplyr::mutate(group = rep(group_names,
                                      times = c(group_start_row[-1] - group_start_row[-length(group_start_row)])))
          
          # Add the single table to a list
          samples.table.list[[i]] = sample.table
        }
        
        names(samples.table.list) = sample_names
        
        return(samples.table.list)
      } # end read matrix function
    
    #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    message("Reading the matrices...")
    matrix_list =
      purrr::map(.x = paste0(matrix.dir, "/", TF_list, matrix.suffix),
                 .f = function(x){return(read.deeptools.matrix(matrix = x,
                                                               missing.data.as.zero = missing.data.as.zero))},
                 .progress = T)
    names(matrix_list) = TF_list

    
    
    # Combination of all matrices in one
    combined_matrices = data.frame()
    
    progressBar_combMat = utils::txtProgressBar(min = 0, max = length(matrix_list), style = 3,
                                                width = ceiling(50/length(matrix_list))*length(matrix_list), char = "\u2588")
    for (i in 1:length(matrix_list)) {
      for (k in 1:length(matrix_list[[i]])) {
        tb = 
          matrix_list[[i]][[k]] %>%
          dplyr::mutate(TF = names(matrix_list)[i],
                        sample = names(matrix_list[[i]])[k],
                        group = as.character(dplyr::filter(sample.groups, sample.ID == names(matrix_list[[i]])[k])$group[1]))
        
        colnames(tb)[1:6] = c("chr", "start", "end", "motif", "score", "strand")
        
        flanking_bp = length(7:(ncol(tb)-3))/2
        colnames(tb)[7:(ncol(tb)-3)] = c(-flanking_bp:flanking_bp)[c(-flanking_bp:flanking_bp) != 0]
        
        combined_matrices = rbind(combined_matrices, tb)
      }
      utils::setTxtProgressBar(progressBar_combMat, i)
    }
    close(progressBar_combMat)
    

    
    
    ### Global scaling to 0-1
    if (scale.zero.one == T) {
      combined_matrices_scaled = combined_matrices
      scores = combined_matrices_scaled[,7:(ncol(tb)-3)] - min(combined_matrices_scaled[,7:(ncol(tb)-3)], na.rm = T)
      scores = scores / max(scores, na.rm = T)
      combined_matrices_scaled = cbind(cbind(combined_matrices_scaled[1:6], scores), combined_matrices_scaled[,(ncol(tb)-2):ncol(tb)])
      
    } else {
      combined_matrices_scaled = combined_matrices
    }
    
    # AUC.per.region = apply(combined_matrices_scaled[,7:(ncol(tb)-3)],
    #                        MARGIN = 1,
    #                        FUN = function(x){DescTools::AUC(x = c(-flanking_bp:flanking_bp)[c(-flanking_bp:flanking_bp) != 0],
    #                                                         y = x,
    #                                                         na.rm = T)})
    
    
    ## Compute the sum of the values over the region (~AUC)
    combined_matrices_scaled$AUC = rowSums(as.matrix(combined_matrices_scaled[,7:(ncol(tb)-3)]))
    
    ## Compute the ratio between sides and center of the region (walls_mean vs footprint of the TF-footprint)
    ### Compute which column to use
    footprint_size = length(7:(ncol(tb)-3))
    n_bases_sector = floor(max(c(1, footprint_size * AUC_sector_fraction)))
    left_sector_cols = (7:(ncol(tb)-3))[1:n_bases_sector]
    right_sector_cols = ((ncol(tb)-3)-n_bases_sector):(ncol(tb)-3)
    center_sector_col = floor(mean(7:(ncol(tb)-3)))
    middle_sector_cols = (center_sector_col-floor(n_bases_sector/2)):(floor(n_bases_sector/2)+center_sector_col)
    
    combined_matrices_scaled$AUC_left = rowSums(as.matrix(combined_matrices_scaled[,left_sector_cols]))
    combined_matrices_scaled$AUC_right = rowSums(as.matrix(combined_matrices_scaled[,right_sector_cols]))
    combined_matrices_scaled$AUC_middle = rowSums(as.matrix(combined_matrices_scaled[,middle_sector_cols]))
    
    combined_matrices_scaled =
      combined_matrices_scaled %>%
      dplyr::mutate(AUC_ratio = ((AUC_left+AUC_right)/2) / AUC_middle) %>%
      dplyr::relocate(group, .after = strand) %>%
      dplyr::relocate(TF, .after = group) %>%
      dplyr::relocate(group, .after = strand) %>%
      dplyr::relocate(sample, .after = TF) %>%
      dplyr::relocate(AUC, .after = sample) %>%
      dplyr::relocate(AUC_left, .after = AUC) %>%
      dplyr::relocate(AUC_middle, .after = AUC_left) %>%
      dplyr::relocate(AUC_right, .after = AUC_middle) %>%
      dplyr::relocate(AUC_ratio, .after = AUC_right)
      
    
    
    ### Generate table with average by group and TF
    message("Generating table with average by group and TF...")
    combined_matrices_scaled_summary =
      combined_matrices_scaled %>%
      dplyr::group_by(chr, start, end, TF, group) %>%
      dplyr::summarise(n = n(),
                       AUC.min = min(AUC, na.rm = T),
                       AUC.max = max(AUC, na.rm = T),
                       AUC.mean = mean(AUC, na.rm = T),
                       AUC.median = median(AUC, na.rm = T),
                       AUC.sd = sd(AUC_ratio, na.rm = T), ##############
                       AUC.ratio.min = min(AUC_ratio, na.rm = T),
                       AUC.ratio.max = max(AUC_ratio, na.rm = T),
                       AUC.ratio.mean = mean(AUC_ratio, na.rm = T),
                       AUC.ratio.median = median(AUC_ratio, na.rm = T),
                       AUC.ratio.sd = sd(AUC_ratio, na.rm = T)) %>%
      dplyr::mutate(AUC.sem = AUC.sd/sqrt(n),
                    AUC.ratio.sem = AUC.ratio.sd/sqrt(n))
    
    
    
    
    
    ### Computing paired distribution comparisons per each comparison-group
    message("Computing distribution differences...")
    all_TF = unique(combined_matrices_scaled$TF)
    stat_per_comparison_list = list()
    violin_per_comparison_list = list()
    volcano_per_comparison_list = list()
    stat_per_comparison_list_ratio = list()
    violin_per_comparison_list_ratio = list()
    volcano_per_comparison_list_ratio = list()
    
    iter_max = length(comparison.list)*length(all_TF)
    progressBar_distri =
      utils::txtProgressBar(min = 0, max = iter_max, width = ceiling(50/iter_max)*iter_max,
                            style = 3, char = "\u2588")
    pb_count = 0
      
    for (i in 1:length(comparison.list)) {
      stat_per_comparison_list[[i]] = data.frame()
      names(stat_per_comparison_list)[i] = paste(comparison.list[[i]], collapse = ".vs.")
      
      violin_per_comparison_list[[i]] = list()
      names(violin_per_comparison_list)[i] = paste(comparison.list[[i]], collapse = ".vs.")
      
      
      stat_per_comparison_list_ratio[[i]] = data.frame()
      names(stat_per_comparison_list_ratio)[i] = paste(comparison.list[[i]], collapse = ".vs.")
      
      violin_per_comparison_list_ratio[[i]] = list()
      names(violin_per_comparison_list_ratio)[i] = paste(comparison.list[[i]], collapse = ".vs.")
      
      for (k in 1:length(all_TF)) {
        violin_per_comparison_list[[i]][[k]] = list()
        names(violin_per_comparison_list[[i]])[k] = all_TF[k]
        
        violin_per_comparison_list_ratio[[i]][[k]] = list()
        names(violin_per_comparison_list_ratio[[i]])[k] = all_TF[k]
        
        filt_tb =
          dplyr::filter(combined_matrices_scaled_summary,
                        group %in% comparison.list[[i]],
                        TF == all_TF[k])
        
        stats =
          suppressMessages(ggpubr::compare_means(data = filt_tb,
                                                 formula = AUC.mean ~ group,
                                                 method = "wilcox",
                                                 paired = paired.stats,
                                                 p.adjust.method = p.adjust.method)) %>%
          dplyr::mutate(TF = all_TF[k],
                        comparison = names(stat_per_comparison_list)[i]) %>%
          dplyr::relocate(comparison, .before = `.y.`) %>%
          dplyr::relocate(TF, .after = comparison)
        
        
        stats_ratio =
          suppressMessages(ggpubr::compare_means(data = filt_tb,
                                                 formula = AUC.ratio.mean ~ group,
                                                 method = "wilcox",
                                                 paired = paired.stats,
                                                 p.adjust.method = p.adjust.method)) %>%
          dplyr::mutate(TF = all_TF[k],
                        comparison = names(stat_per_comparison_list)[i]) %>%
          dplyr::relocate(comparison, .before = `.y.`) %>%
          dplyr::relocate(TF, .after = comparison)
        
        
        counts =
          ggpubr::desc_statby(filt_tb,
                              measure.var = "AUC.mean",
                              grps = c("TF", "group"))
        
        
        counts_ratio =
          ggpubr::desc_statby(filt_tb,
                              measure.var = "AUC.ratio.mean",
                              grps = c("TF", "group"))
        
        
        # stats mean
        stats$mean_group1 = counts[which(counts$group == stats$group1),"mean"]
        stats$mean_group2 = counts[which(counts$group == stats$group2),"mean"]
        stats$log2_mean.FC_2.vs.1 = log2(stats$mean_group2 / stats$mean_group1)
        stats$mean.FC_difference_2.vs.1 = stats$mean_group2 - stats$mean_group1
        
        stat_per_comparison_list[[i]] =
          rbind(stat_per_comparison_list[[i]],
                stats)
        
        
        # stats ratio
        stats_ratio$mean_group1 = counts_ratio[which(counts_ratio$group == stats_ratio$group1),"mean"]
        stats_ratio$mean_group2 = counts_ratio[which(counts_ratio$group == stats_ratio$group2),"mean"]
        stats_ratio$log2_ratio.FC_2.vs.1 = log2(stats_ratio$mean_group2 / stats_ratio$mean_group1)
        stats_ratio$ratio.FC_difference_2.vs.1 = stats_ratio$mean_group2 - stats_ratio$mean_group1
        
        stat_per_comparison_list_ratio[[i]] =
          rbind(stat_per_comparison_list_ratio[[i]],
                stats_ratio)
        
        
        
      
        ## Plot comparison distribution (mean)
        violin_per_comparison_list[[i]][[k]] =
          ggplot(data =
                   filt_tb %>%
                   dplyr::mutate(group = factor(group, levels = comparison.list[[i]])),
                 aes(x = group,
                     y = log2(AUC.mean+1))) +
          geom_violin(aes(fill = group),
                      color = NA,
                      position = position_dodge(),
                      show.legend = F) +
          scale_fill_manual(values = group.colors) +
          geom_boxplot(aes(color = group),
                       fill = "white",
                       width = 0.1,
                       position = position_dodge(),
                       outlier.color = "black",
                       outlier.stroke = NA,
                       outlier.alpha = 0.3,
                       show.legend = F) +
          scale_color_manual(values = group.colors) +
          ggpubr::stat_compare_means(method = "wilcox",
                                     paired = T,
                                     label = p.label.format, na.rm = T, 
                                     comparisons = list(comparison.list[[i]]),
                                     p.adjust.method = p.adjust.method) +
          ggtitle(paste0("**", all_TF[k], "**: log<sub>2</sub>(FC<sub>",
                         gsub("[.]vs[.]","/", names(stat_per_comparison_list)[i]), "</sub>) = ",
                         signif(stats$log2_mean.FC_2.vs.1[1], 3))) +
          xlab(NULL) +
          ylab("log<sub>2</sub>(mean<sub>reps</sub> + 1)") +
          theme_classic() +
          theme(axis.text = element_text(color = "black"),
                axis.title.y = ggtext::element_markdown(color = "black"),
                axis.ticks.x = element_blank(),
                plot.title = ggtext::element_markdown(color = "black"),
                axis.ticks.y = element_line(color = "black"))
        
        
        # Plot comparison distribution (mean)
        violin_per_comparison_list_ratio[[i]][[k]] =
          ggplot(data =
                   filt_tb %>%
                   dplyr::mutate(group = factor(group, levels = comparison.list[[i]])),
                 aes(x = group,
                     y = log2(AUC.ratio.mean+1))) +
          geom_violin(aes(fill = group),
                      color = NA,
                      position = position_dodge(),
                      show.legend = F) +
          scale_fill_manual(values = group.colors) +
          geom_boxplot(aes(color = group),
                       fill = "white",
                       width = 0.1,
                       position = position_dodge(),
                       outlier.color = "black",
                       outlier.stroke = NA,
                       outlier.alpha = 0.3,
                       show.legend = F) +
          scale_color_manual(values = group.colors) +
          ggpubr::stat_compare_means(method = "wilcox",
                                     paired = T,
                                     label = p.label.format, na.rm = T, 
                                     comparisons = list(comparison.list[[i]]),
                                     p.adjust.method = p.adjust.method) +
          ggtitle(paste0("**", all_TF[k], "**: log<sub>2</sub>(Depth FC<sub>",
                         gsub("[.]vs[.]","/", names(stat_per_comparison_list_ratio)[i]), "</sub>) = ",
                         signif(stats_ratio$log2_ratio.FC_2.vs.1[1], 3))) +
          xlab(NULL) +
          ylab("log<sub>2</sub>(Depth mean<sub>reps</sub> + 1)") +
          theme_classic() +
          theme(axis.text = element_text(color = "black"),
                axis.title.y = ggtext::element_markdown(color = "black"),
                axis.ticks.x = element_blank(),
                plot.title = ggtext::element_markdown(color = "black"),
                axis.ticks.y = element_line(color = "black"))
        
        pb_count = pb_count+1
        utils::setTxtProgressBar(progressBar_distri, pb_count)
      } # END stats
      
      
      ## add differential status
      stat_per_comparison_list[[i]] =
        stat_per_comparison_list[[i]] %>%
        #dplyr::mutate(differential = abs(log2_mean.FC_2.vs.1) >= log2(FC.linear.threshold) & p.adj < p.adj.threshold)
        dplyr::mutate(differential = p.adj < p.adj.threshold)
      
      
      stat_per_comparison_list_ratio[[i]] =
        stat_per_comparison_list_ratio[[i]] %>%
        #dplyr::mutate(differential = abs(log2_ratio.FC_2.vs.1) >= log2(ratio.FC.linear.threshold) & p.adj < p.adj.threshold)
        dplyr::mutate(differential = p.adj < p.adj.threshold)
      
      
      ## generate volcano of the foldchanges per comparison (MEAN)
      volcano_per_comparison_list[[i]] =
        ggplot(data = stat_per_comparison_list[[i]],
               aes(x = log2_mean.FC_2.vs.1,
                   y = -log10(p.adj),
                   size = -log10(p.adj))) +
        geom_point(stroke = NA,
                   alpha = 0.75) +
        theme_classic() +
        geom_hline(yintercept = -log10(p.adj.threshold), linetype = 2) +
        geom_vline(xintercept = 0, linetype = 2) +
        #geom_vline(xintercept = log2(FC.linear.threshold)*c(-1,1), linetype = 2) +
        ggtitle(gsub("[.]vs[.]"," vs ", names(stat_per_comparison_list)[i])) +
        ylab("-log<sub>10</sub>(*P*<sub>adj</sub>)") +
        xlab("log<sub>2</sub>(FC<sub>mean</sub>)") +
        theme(axis.text = ggtext::element_markdown(color = "black"),
              axis.title.y = ggtext::element_markdown(color = "black"),
              axis.title.x = ggtext::element_markdown(color = "black"),
              plot.title = ggtext::element_markdown(color = "black"),
              axis.ticks = element_line(color = "black"))
      
      diff_TF = dplyr::filter(stat_per_comparison_list[[i]], differential == T)
      
      # add differential labels
      if (add.label.diffTF == TRUE & nrow(diff_TF)>0) {
        volcano_per_comparison_list[[i]] =
          volcano_per_comparison_list[[i]] +
          ggrepel::geom_text_repel(data = diff_TF,
                                   aes(x = log2_mean.FC_2.vs.1,
                                       y = -log10(p.adj),
                                       label = TF),
                                   force = 5,
                                   min.segment.length = 0,
                                   max.overlaps = max.overlap.labels,
                                   inherit.aes = F)
      }
      
      # make plot symmetric
      volcano_per_comparison_list[[i]] =
        volcano_per_comparison_list[[i]] +
        xlim(c(-1,1)*max(abs(ggplot_build(volcano_per_comparison_list[[i]])$layout$panel_params[[1]]$x.range)))
      
      
      
      
      ## generate volcano of the foldchanges per comparison (SECTOR RATIO)
      volcano_per_comparison_list_ratio[[i]] =
        ggplot(data = stat_per_comparison_list_ratio[[i]],
               aes(x = log2_ratio.FC_2.vs.1,
                   y = -log10(p.adj),
                   size = -log10(p.adj))) +
        geom_point(stroke = NA,
                   alpha = 0.75) +
        theme_classic() +
        geom_hline(yintercept = -log10(p.adj.threshold), linetype = 2) +
        geom_vline(xintercept = 0, linetype = 2) +
        #geom_vline(xintercept = log2(ratio.FC.linear.threshold)*c(-1,1), linetype = 2) +
        ggtitle(gsub("[.]vs[.]"," vs ", names(stat_per_comparison_list_ratio)[i])) +
        ylab("-log<sub>10</sub>(*P*<sub>adj</sub>)") +
        xlab("log<sub>2</sub>(Depth FC<sub>mean</sub>)") +
        theme(axis.text = ggtext::element_markdown(color = "black"),
              axis.title.y = ggtext::element_markdown(color = "black"),
              axis.title.x = ggtext::element_markdown(color = "black"),
              plot.title = ggtext::element_markdown(color = "black"),
              axis.ticks = element_line(color = "black"))
      
      diff_TF = dplyr::filter(stat_per_comparison_list_ratio[[i]], differential == T)
      
      # add differential labels
      if (add.label.diffTF == TRUE & nrow(diff_TF)>0) {
        volcano_per_comparison_list_ratio[[i]] =
          volcano_per_comparison_list_ratio[[i]] +
          ggrepel::geom_text_repel(data = diff_TF,
                                   aes(x = log2_ratio.FC_2.vs.1,
                                       y = -log10(p.adj),
                                       label = TF),
                                   force = 5,
                                   min.segment.length = 0,
                                   max.overlaps = max.overlap.labels,
                                   inherit.aes = F)
      }
      
      # make plot symmetric
      volcano_per_comparison_list_ratio[[i]] =
        volcano_per_comparison_list_ratio[[i]] +
        xlim(c(-1,1)*max(abs(ggplot_build(volcano_per_comparison_list_ratio[[i]])$layout$panel_params[[1]]$x.range)))
      
    }
    close(progressBar_distri)
    
    names(volcano_per_comparison_list) = names(stat_per_comparison_list)
    names(volcano_per_comparison_list_ratio) = names(stat_per_comparison_list_ratio)
    
    
    
    ## ----------------------------------------------------------------------------------------------------------
    ## PLOT THE FOOTPRINTS
    ## ----------------------------------------------------------------------------------------------------------
    
    # Reshape/melt the table
    combined_matrices_scaled_minimal =
      dplyr::mutate(.data = combined_matrices_scaled,
                    region.id = paste(chr, start, end, sep = "_")) %>%
      dplyr::relocate(region.id, .after = end) %>%
      dplyr::select(-c("chr", "start", "end", "motif", "score", "strand",
                       "AUC", "AUC_left", "AUC_middle", "AUC_right", "AUC_ratio"))
    
    combined_TF = unique(combined_matrices_scaled_minimal$TF)
    
    
    message("Reshaping score tables for footprinting...")
    combined_matrices_scaled_ggplot =
      reshape2::melt(data = combined_matrices_scaled_minimal,
                   value.name = "score",
                   variable.name = "position",
                   id.vars = c("region.id", "group", "TF", "sample"))
    
    combined_matrices_scaled_ggplot =
      combined_matrices_scaled_ggplot %>%
      dplyr::group_by(group, TF, position) %>%
      dplyr::summarise(n = n(),
                       score_mean = mean(score, na.rm = T),
                       score_median = median(score, na.rm = T),
                       score_sum = sum(score, na.rm = T),
                       score_sd = sd(score, na.rm = T)) %>%
      dplyr::mutate(score_sem = score_sd / sqrt(n))
    
    
    
    for (i in 1:length(unique(combined_matrices_scaled_minimal$TF)))
      
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ### Distribution summary
    golbal_stat =
      combined_matrices_scaled %>%
      dplyr::group_by(TF, sample) %>%
      dplyr::summarise(AUC.mean = mean(AUC, na.rm = T),
                       AUC.median = median(AUC, na.rm = T))
    
    
    ### Computing summary and comparison of distributions
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # ------------------------------------------------------------------------------------------------------
    ### Read score tables and run foorprint analyses
    score_list = list()
    
    for (i in 1:length(TF_list)) {
      score_list[[i]] =
        data.frame(data.table::fread(paste0(matrix.dir,"/",TF_list[i],matrix.suffix), skip = 2) %>%
                     tidyr::separate(col = V1, sep = "\t", into = c("sample.ID", "TF", "V1")))
      
      score_list[[i]] =
        dplyr::left_join(score_list[[i]],
                         sample.groups,
                         by = "sample.ID") %>%
        dplyr::mutate(group = factor(group, levels = levels))
    }
    names(score_list) = TF_list
    
    
    
    ### Run footprint analyses and plots by group
    reshaped_score_list = list()
    reshaped_score_mean_list = list()
    footprint_list = list()
    
    for (i in 1:length(TF_list)) {
      # Reshaping score table
      reshaped_score_list[[i]] = data.frame()
      flanking = ceiling((ncol(score_list[[i]]) - 3)/2)
      
      for (k in 1:nrow(score_list[[i]])) {
        reshaped_score_list[[i]] = rbind(reshaped_score_list[[i]],
                                         data.frame(sample.ID = score_list[[i]]$sample[k],
                                                    group = as.vector(score_list[[i]]$group[k]),
                                                    TF = TF_list[i],
                                                    distance_center_bp = c(-flanking:flanking)[-(flanking+1)],
                                                    score = as.numeric(t(score_list[[i]][k,3:(ncol(score_list[[i]])-1)])[,1])))
      }
      
      # bring to zero if required
      if (scale.zero.one == TRUE) {
        reshaped_score_list[[i]] =
          reshaped_score_list[[i]] %>%
          dplyr::mutate(score = score - min(score)) %>%
          dplyr::mutate(score = score / max(score))
      }
      
      # Compute mean+stats by group at each position
      reshaped_score_mean_list[[i]] =
        data.frame(reshaped_score_list[[i]] %>%
                     dplyr::group_by(distance_center_bp, group, TF) %>%
                     dplyr::summarise(n = n(),
                                      score_mean = mean(score, na.rm = T),
                                      SD = sd(score, na.rm = T),
                                      SEM = sd(score, na.rm = T)/sqrt(n()),
                                      .groups = "keep") %>%
                     dplyr::mutate(group = factor(group, levels = levels)) %>%
                     dplyr::arrange(group, distance_center_bp))
      
      
      ### Generate footprint plot
      footprint_list[[i]] =
        ggplot(reshaped_score_mean_list[[i]],
               aes(x = distance_center_bp,
                   y = score_mean,
                   color = group,
                   fill = group)) +
        geom_ribbon(data = reshaped_score_mean_list[[i]],
                    aes(x = distance_center_bp,
                        ymin = score_mean-SEM,
                        ymax = score_mean+SEM),
                    alpha = error.transparency,
                    color = NA) +
        geom_line() +
        scale_color_manual(values = group.colors) +
        scale_fill_manual(values = group.colors) +
        ggtitle(TF_list[i]) +
        xlab("Distance from motif center [bp]") +
        ylab("mean Footprint score \u00B1 SEM") +
        theme_classic() +
        theme(axis.text = element_text(color = "black"),
              axis.ticks = element_line(color = "black"),
              plot.title = element_text(hjust = 0.5))
    }
    names(reshaped_score_list) = TF_list
    names(reshaped_score_mean_list) = TF_list
    names(footprint_list) = TF_list
    
    
    # ----------------------------------------------------------------------------------------------------
    ### Compute area under the curve (AUC)
    AUC_bySample = list()
    AUC_byGroup = list()
    
    for (i in 1:length(TF_list)) {
      # table by sample
      AUC_bySample[[i]] =
        reshaped_score_list[[i]] %>%
        dplyr::group_by(sample.ID, group, TF) %>%
        dplyr::summarise(AUC = DescTools::AUC(x = distance_center_bp,
                                              y = score,
                                              na.rm = T),
                         .groups = "keep") %>%
        dplyr::mutate(group = factor(group, levels = levels)) %>%
        dplyr::arrange(group)
      
      
      # Heatmap table (bySample)
      heatmap_mat_bySample = matrix(AUC_bySample[[i]]$AUC, nrow = 1)
      colnames(heatmap_mat_bySample) = AUC_bySample[[i]]$sample.ID
      rownames(heatmap_mat_bySample) = unique(AUC_bySample[[i]]$TF)
      
      if (i == 1) {
        heatmap_matrix_bySample = heatmap_mat_bySample
      } else {
        heatmap_matrix_bySample = rbind(heatmap_matrix_bySample, heatmap_mat_bySample)
      }
      
      
      
      # Table by Group
      AUC_byGroup[[i]] =
        AUC_bySample[[i]] %>%
        dplyr::group_by(group, TF) %>%
        dplyr::summarise(n = n(),
                         AUC_mean = mean(AUC, na.rm = T),
                         AUC.SD = sd(AUC, na.rm = T),
                         AUC.SEM = sd(AUC, na.rm = T)/sqrt(n()),
                         .groups = "keep") %>%
        dplyr::mutate(group = factor(group, levels = levels)) %>%
        dplyr::arrange(group)
      
      
      # Heatmap table (byGroup)
      heatmap_mat_byGroup = matrix(AUC_byGroup[[i]]$AUC_mean, nrow = 1)
      colnames(heatmap_mat_byGroup) = as.vector(AUC_byGroup[[i]]$group)
      rownames(heatmap_mat_byGroup) = unique(AUC_byGroup[[i]]$TF)
      
      if (i == 1) {
        heatmap_matrix_byGroup = heatmap_mat_byGroup
      } else {
        heatmap_matrix_byGroup = rbind(heatmap_matrix_byGroup, heatmap_mat_byGroup)
      }
    }
    names(AUC_byGroup) = TF_list
    names(AUC_bySample) = TF_list
    
    
    # Computing the Fold_Changes + stats of the required comparisons
    FC_table_list = list()
    FC_MAplot_list = list()
    Diff_MAplot_list = list()
    
    for (j in 1:length(comparison.list)) {
      FC_table_list[[j]] = data.frame()
      
      for (i in 1:length(TF_list)) {
        if (ignore.statistics == F) {
          wilcox_test = wilcox.test(x = dplyr::filter(AUC_bySample[[i]], group == comparison.list[[j]][1])$AUC,
                                    y = dplyr::filter(AUC_bySample[[i]], group == comparison.list[[j]][2])$AUC,
                                    paired = paired.stats,
                                    conf.level = confidence.level,
                                    conf.int = compute.confidence.interval)
        } else {
          wilcox_test = list(p.value = 0, estimate = 0)
        }
        
        FC_table_list[[j]] = rbind(FC_table_list[[j]],
                                   data.frame(TF = TF_list[[i]],
                                              group.A = comparison.list[[j]][1],
                                              group.B = comparison.list[[j]][2],
                                              basemean.AUC = mean(dplyr::filter(AUC_bySample[[i]], group %in% comparison.list[[j]])$AUC, na.rm=T),
                                              mean.AUC.A = mean(dplyr::filter(AUC_bySample[[i]], group == comparison.list[[j]][1])$AUC, na.rm=T),
                                              mean.AUC.B = mean(dplyr::filter(AUC_bySample[[i]], group == comparison.list[[j]][2])$AUC, na.rm=T)) %>%
                                     dplyr::mutate(`difference.mean.AUC.A-B` = mean.AUC.A - mean.AUC.B,
                                                   Foldchange_A.vs.B = abs(mean.AUC.A / mean.AUC.B),
                                                   p.value = wilcox_test$p.value,
                                                   p.adjusted = wilcox_test$p.value,
                                                   difference.in.location = as.vector(wilcox_test$estimate)))
      }
      
      # Adjust p.values
      FC_table_list[[j]] =
        dplyr::mutate(FC_table_list[[j]],
                      p.adjusted = p.adjust(p.value,
                                            method = p.adjust.method,
                                            n = length(p.value))) %>%
        dplyr::mutate(activity = ifelse((Foldchange_A.vs.B >= foldChange.threshold) & (abs(basemean.AUC) > basemean.AUC.threshold),
                                        yes = "differential", no = "unresponsive")) %>%
        dplyr::mutate(activity = factor(activity, levels = c("differential", "unresponsive")))
      
      names(FC_table_list)[j] = paste0(comparison.list[[j]][1], ".vs.", comparison.list[[j]][2])
      
      
      #*** plot MA-plots on the foldchanges
      FC_MAplot_list[[j]] =
        ggplot(data = FC_table_list[[j]],
               aes(x = basemean.AUC,
                   y = log2(Foldchange_A.vs.B),
                   color = activity)) +
        geom_point(size = 2, alpha = 0.5) +
        scale_color_manual(values = c("differential" = "indianred",
                                      "unresponsive" = "gray50"),
                           drop = F) +
        ggtitle(paste0(comparison.list[[j]][1], " vs ", comparison.list[[j]][2])) +
        xlab(paste0("mean AUC (", comparison.list[[j]][1], ":", comparison.list[[j]][2], ")")) +
        ylab(paste0("log2(AUC Foldchange): ", comparison.list[[j]][1], " / ", comparison.list[[j]][2])) +
        geom_hline(yintercept = log2(1), linetype = "dotted", color = "gray50") +
        geom_hline(yintercept = c(-1,1)*log2(foldChange.threshold), linetype = "dashed", color = "steelblue") +
        geom_vline(xintercept = basemean.AUC.threshold, linetype = "dashed", color = "steelblue") +
        theme_classic() +
        theme(axis.text = element_text(color = "black"),
              axis.ticks = element_line(color = "black"),
              plot.title = element_text(hjust = 0.5))
      
      # Add significant TF.names if required
      if (MAplot.show.names == TRUE) {
        FC_MAplot_list[[j]] =
          FC_MAplot_list[[j]] + 
          ggrepel::geom_text_repel(data = FC_table_list[[j]] %>% dplyr::filter(activity == "differential"),
                                   aes(x = basemean.AUC,
                                       y = log2(Foldchange_A.vs.B),
                                       color = activity,
                                       label = TF),
                                   max.overlaps = 100,
                                   force = 5,
                                   size = 3,
                                   show.legend = F)
      }
      
      # Make y-axis symmetric
      ggbuild = ggplot_build(FC_MAplot_list[[j]])
      y.max = max(abs(ggbuild$layout$panel_params[[1]]$y.range))
      FC_MAplot_list[[j]] = FC_MAplot_list[[j]] + ylim(c(-y.max, y.max))
      
      names(FC_MAplot_list)[j] = paste0(comparison.list[[j]][1], ".vs.", comparison.list[[j]][2])
      
      
      
      #*** plot MA-plots on the _differences_
      # get quantiles fo threshold
      quantiles = quantile(log2(FC_table_list[[j]]$`difference.mean.AUC.A-B`+1),
                           c(percentage.top.hits/100, 1-(percentage.top.hits/100)),
                           na.rm = T)
      
      Diff_MAplot_list[[j]] =
        ggplot(data = FC_table_list[[j]] %>% dplyr::filter(log2(`difference.mean.AUC.A-B`+1)>quantiles[1] & log2(`difference.mean.AUC.A-B`+1)<quantiles[2]),
               aes(x = basemean.AUC,
                   y = log2(`difference.mean.AUC.A-B`+1))) +
        geom_point(size = 2, alpha = 0.5, show.legend = F, color = "gray50") +
        geom_point(data = FC_table_list[[j]] %>% dplyr::filter((log2(`difference.mean.AUC.A-B`+1)<=quantiles[1] | log2(`difference.mean.AUC.A-B`+1)>=quantiles[2]) & (abs(basemean.AUC) > basemean.AUC.threshold)),
                   size = 2, alpha = 0.5, show.legend = F, color = "#07c22c") +
        ggtitle(paste0(comparison.list[[j]][1], " vs ", comparison.list[[j]][2], " (top ", percentage.top.hits, "%)")) +
        xlab(paste0("mean AUC (", comparison.list[[j]][1], ":", comparison.list[[j]][2], ")")) +
        ylab(paste0("log2(AUC difference + 1): ", comparison.list[[j]][1], " - ", comparison.list[[j]][2])) +
        geom_hline(yintercept = log2(1), linetype = "dotted", color = "gray50") +
        geom_hline(yintercept = quantiles, linetype = "dashed", color = "steelblue") +
        geom_vline(xintercept = basemean.AUC.threshold, linetype = "dashed", color = "steelblue") +
        theme_classic() +
        theme(axis.text = element_text(color = "black"),
              axis.ticks = element_line(color = "black"),
              plot.title = element_text(hjust = 0.5))
      
      # Add significant TF.names if required
      if (MAplot.show.names == TRUE) {
        Diff_MAplot_list[[j]] =
          Diff_MAplot_list[[j]] + 
          ggrepel::geom_text_repel(data = FC_table_list[[j]] %>% dplyr::filter((log2(`difference.mean.AUC.A-B`+1)<=quantiles[1] | log2(`difference.mean.AUC.A-B`+1)>=quantiles[2]) & (abs(basemean.AUC) > basemean.AUC.threshold)),
                                   aes(x = basemean.AUC,
                                       y = log2(`difference.mean.AUC.A-B`+1),
                                       label = TF),
                                   color = "#07c22c",
                                   max.overlaps = 100,
                                   force = 5,
                                   size = 3,
                                   show.legend = F)
      }
      
      # Make y-axis symmetric
      ggbuild = ggplot_build(Diff_MAplot_list[[j]])
      y.max = max(abs(ggbuild$layout$panel_params[[1]]$y.range))
      Diff_MAplot_list[[j]] = Diff_MAplot_list[[j]] + ylim(c(-y.max, y.max))
      
      names(Diff_MAplot_list)[j] = paste0(comparison.list[[j]][1], ".vs.", comparison.list[[j]][2])
      
    }
    
    
    
    
    # ----------------------------------------------------------------------------------------------------
    ### Plot heatmap for all conditions (by Sample)
    palette = colorRampPalette(RColorBrewer::brewer.pal(n = 9, name = heatmap.palette))(heatmap.nColors)
    
    # build sample annotations (bySample)
    col_anno_bySample = data.frame(group = sample.groups$group)
    rownames(col_anno_bySample) = sample.groups$sample.ID
    
    # build sample annotations (byGroup)
    col_anno_byGroup = data.frame(group = levels)
    rownames(col_anno_byGroup) = levels
    
    # build sample color annotations
    col_anno_colors = list(group.colors)
    names(col_anno_colors[[1]]) = levels
    names(col_anno_colors) = "group"
    
    
    
    # Plot linear and z-score heatmap (bySample)
    heatmap_linear_bySample %<a-%
      pheatmap::pheatmap(mat = heatmap_matrix_bySample,
                         cluster_rows = heatmap.cluster.rows,
                         cluster_cols = heatmap.cluster.columns,
                         show_rownames = heatmap.showRowNames,
                         show_colnames = heatmap.showColNames,
                         scale = "none",
                         kmeans_k = heatmap.n.row.kmeans,
                         border_color = heatmap.border.color,
                         annotation_col = col_anno_bySample,
                         annotation_colors = col_anno_colors,
                         color = palette,
                         na_col = palette[1])
    
    heatmap_scaled_bySample %<a-%
      pheatmap::pheatmap(mat = heatmap_matrix_bySample,
                         cluster_rows = heatmap.cluster.rows,
                         cluster_cols = heatmap.cluster.columns,
                         show_rownames = heatmap.showRowNames,
                         show_colnames = heatmap.showColNames,
                         scale = heatmap.scaling.mode,
                         kmeans_k = heatmap.n.row.kmeans,
                         border_color = heatmap.border.color,
                         annotation_col = col_anno_bySample,
                         annotation_colors = col_anno_colors,
                         color = palette,
                         na_col = palette[1])
    
    
    # Plot linear and z-score heatmap (byGroup)
    heatmap_linear_byGroup %<a-%
      pheatmap::pheatmap(mat = heatmap_matrix_byGroup,
                         cluster_rows = heatmap.cluster.rows,
                         cluster_cols = heatmap.cluster.columns,
                         show_rownames = heatmap.showRowNames,
                         show_colnames = heatmap.showColNames,
                         scale = "none",
                         kmeans_k = heatmap.n.row.kmeans,
                         border_color = heatmap.border.color,
                         annotation_col = col_anno_byGroup,
                         annotation_colors = col_anno_colors,
                         color = palette,
                         na_col = palette[1])
    
    heatmap_scaled_byGroup %<a-%
      pheatmap::pheatmap(mat = heatmap_matrix_byGroup,
                         cluster_rows = heatmap.cluster.rows,
                         cluster_cols = heatmap.cluster.columns,
                         show_rownames = heatmap.showRowNames,
                         show_colnames = heatmap.showColNames,
                         scale = heatmap.scaling.mode,
                         kmeans_k = heatmap.n.row.kmeans,
                         border_color = heatmap.border.color,
                         annotation_col = col_anno_byGroup,
                         annotation_colors = col_anno_colors,
                         color = palette,
                         na_col = palette[1])
    
    
    # ----------------------------------------------------------------------------------------------------
    ### Building the output list
    output_list =
      list(metadata = list(sample.configuration = sample.groups,
                           comparisons = comparison.list,
                           TF.analyzed = TF_list,
                           group.colors = col_anno_colors[[1]]),
           source.data = list(source.tables = score_list,
                              ggplot.format.source.tables = reshaped_score_list),
           footprint.analyses = list(ggplot.format.group.means = reshaped_score_mean_list,
                                     footprint.plots = footprint_list),
           AUC.analyses = list(AUC.table.bySample = AUC_bySample,
                               AUC.table.byGroup = AUC_byGroup,
                               AUC.foldchange.comparisons = FC_table_list,
                               AUC.comparisons.FC.MAplot = FC_MAplot_list,
                               AUC.comparisons.delta.MAplot = Diff_MAplot_list,
                               heatmaps = list(matrix.AUC.bySample = heatmap_matrix_bySample,
                                               matrix.AUC.byGroup = heatmap_matrix_byGroup,
                                               heatmap.AUC.bySample.raw = heatmap_linear_bySample,
                                               heatmap.AUC.byGroup.raw = heatmap_linear_byGroup,
                                               heatmap.AUC.bySample.zScore = heatmap_scaled_bySample,
                                               heatmap.AUC.byGroup.zScore = heatmap_scaled_byGroup,
                                               hetamap.annotations = list(sample.annotations = col_anno_bySample,
                                                                          group.annotations = col_anno_byGroup,
                                                                          group.annotation.colors = col_anno_colors))))
    
    return(output_list)
  } # END function
    
    #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
