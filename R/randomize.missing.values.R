#' @title randomize.missing.values
#'
#' @description Function that allows to assign random values (from the bottom-X percent of the LFQ values distribution) to proteins that show missing values for all the replicates of a specific condition.
#'
#' @param DEprot.object A \code{DEprot object}, as generated by \link{load.counts}.
#' @param group.column String indicating a column for the metadata table which indicates the IDs of the conditions within which the missing values should be tested.
#' @param tail.percentage Numeric value between 0 and 100 (excluded) indicating the threshold percentage of the distribution from which random values should be sampled. Default: \code{3} (percent).
#' @param percentage.missing Numeric value between 0 and 100 (included) indicated the minimal percentage of missing values per group required to apply the imputation. For instance, if \code{percentage.missing = 75} and the sample group contains 4 samples, imputation will be applied when at least 3 out of 4 values are missing. Default: \code{100} (all values are missing in the group).
#' @param seed Numeric value value indicating the random seed used for the imputation. By default a random integer between 0 and 50000 is selected (if \code{verbose = TRUE} a message is printed indicating the seed used).
#' @param verbose Logical value to define whether the message indicating which random seed was used should be printed. Default: \code{TRUE}.
#'
#' @return A \code{DEprot} object in which values for proteins which display a number of NAs above a user-defined threshold have been substituted in the normalized counts table with bottom-distribution random values.
#'
#' @import dplyr
#' @import ggplot2
#'
#' @export randomize.missing.values



randomize.missing.values =
  function(DEprot.object,
           group.column,
           percentage.missing = 100,
           tail.percentage = 3,
           seed = floor(runif(n = 1, min = 0, max = 50000)),
           verbose = TRUE) {


    # ### Libraries
    # require(dplyr)
    # require(ggplot2)


    ### check object
    if (!("DEprot" %in% class(DEprot.object))) {
      stop("The input must be an object of class 'DEprot'.")
      #return(DEprot.object)
    }


    ### Check if normalized data are available
    if (DEprot.object@normalized == FALSE) {
      stop("The 'DEprot' object must contain normalized counts.")
      #return(DEprot.object)
    } else {
      counts = DEprot.object@norm.counts
    }


    ### Check that the group column is available
    if (!(group.column %in% colnames(DEprot.object@metadata))) {
      stop("The 'group.column' provided is not available in the metadata column names.")
      #return(DEprot.object)
    } else {
      groups = unique(DEprot.object@metadata[, group.column])
    }


    ### Collect col.names of the normalized data
    original.column.order = colnames(counts)


    ### Collect the "data pool" from which pick the random values
    if (tail.percentage > 0 & tail.percentage < 100) {
      threshold = quantile(as.matrix(counts), na.rm = TRUE, probs = tail.percentage/100)
      random.pool = as.vector(counts[counts<threshold])
      random.pool = random.pool[!is.na(random.pool)]
    } else {
      stop("The 'tail.percentage' must be a number between 0 and 100 (excluded).")
      #return(DEprot.object)
    }


    ### Check percentage of missing values
    if (percentage.missing < 0 | percentage.missing > 100) {
      stop("The 'percentage.missinge' must be a number between 0 and 100 (included).")
      #return(DEprot.object)
    }




    ### Replace completely/percentage missing values in a group
    set.seed(seed)
    if (verbose == TRUE){message(paste0("Random Seed used: ", seed))}

    list.counts = list()

    for (i in 1:length(groups)) {
      samples.in.group = DEprot.object@metadata$column.id[DEprot.object@metadata[,group.column] == groups[i]]
      counts.subset = counts[,samples.in.group]
      n.samples = length(samples.in.group)

      # count NAs per row
      n.NA.per.row = rowSums(is.na(counts.subset))

      # identify proteins for which imputation is required (# missing prot >= percentage.missing)
      prot.missing = names(n.NA.per.row)[n.NA.per.row >= floor((percentage.missing/100) * n.samples)]

      ## assign random values to this subset (if a protein has completely missing values)
      if (length(prot.missing) > 0) {
        n.missing.values = length(counts.subset[prot.missing,][is.na(counts.subset[prot.missing,])])
        counts.subset[prot.missing,][is.na(counts.subset[prot.missing,])] = sample(x = random.pool, size = n.missing.values, replace = TRUE)
      }

      list.counts[[i]] = counts.subset
    }


    ### combine new tables
    randomized.counts = do.call(cbind, list.counts)
    randomized.counts = randomized.counts[,original.column.order]


    ### substitute the counts in the original object and return the latter
    DEprot.object@norm.counts = as.matrix(randomized.counts)
    DEprot.object@boxplot.norm =
      DEprot::plot.counts(DEprot.object = DEprot.object,
                          which.data = "norm",
                          violin.color = "purple") +
      ggtitle(label = DEprot.object@boxplot.norm$labels$title,
              subtitle = DEprot.object@boxplot.norm$labels$subtitle)


    return(DEprot.object)
  } ## END function
