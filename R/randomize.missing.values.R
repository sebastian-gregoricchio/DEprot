#' @title randomize.missing.values
#'
#' @description Function that allows to assign random values (from the bottom-X percent of the LFQ values distribution) to proteins that show missing values for all the replicates of a specific condition.
#'
#' @param DEprot.object A \code{DEprot object}, as generated by \link{load.counts}.
#' @param group.column String indicating a column for the metadata table which indicates the IDs of the conditions within which the missing values should be tested.
#' @param tail.percentage Numeric value between 0 and 100 (excluded) indicating the threshold percentage of the distribution from which random values should be sampled. Default: \code{5} (percent).
#'
#' @return A \code{DEprot} object in which the completely missing values have been substituted in the normalized counts table.
#'
#' @export randomize.missing.values



randomize.missing.values =
  function(DEprot.object,
           group.column,
           tail.percentage = 5) {


    ### Libraries
    require(dplyr)
    require(ggplot2)


    ### check object
    if (!("DEprot" %in% class(DEprot.object))) {
      warning("The input must be an object of class 'DEprot'.")
      return(DEprot.object)
    }


    ### Check if normalized data are available
    if (DEprot.object@normalized == F) {
      warning("The 'DEprot' object must contain normalized counts.")
      return(DEprot.object)
    } else {
      counts = DEprot.object@norm.counts
    }


    ### Check that the group column is available
    if (!(group.column %in% colnames(DEprot.object@metadata))) {
      warning("The 'group.column' provided is not available in the metadata column names.")
      return(DEprot.object)
    } else {
      groups = unique(DEprot.object@metadata[, group.column])
    }


    ### Collect col.names of the normalized data
    original.column.order = colnames(counts)


    ### Collect the "data pool" from which pick the random values
    if (tail.percentage > 0 & tail.percentage < 100) {
      threshold = quantile(as.matrix(counts), na.rm = T, probs = tail.percentage/100)
      random.pool = as.vector(counts[counts<threshold])
      random.pool = random.pool[!is.na(random.pool)]
    } else {
      warning("The 'tail.percentage' must be a number between 0 and 100 (excluded).")
      return(DEprot.object)
    }




    ### Replace completely missing values in a group
    set.seed(set.seed(runif(n = 1, min = 0, max = 300)))

    list.counts = list()

    for (i in 1:length(groups)) {
      samples.in.group = DEprot.object@metadata$column.id[DEprot.object@metadata[,group.column] == groups[i]]
      counts.subset = counts[,samples.in.group]
      n.samples = length(samples.in.group)

      ## identify proteins with completely missing values
      prot.missing = rownames(counts.subset[rowSums(counts.subset, na.rm = T) == 0,])

      ## assign random values to this subset (if a protein has completely missing values)
      if (length(prot.missing) > 0) {
        for (k in 1:length(prot.missing)) {
          counts.subset[prot.missing[k],] = sample(x = random.pool, size = n.samples)
        }
      }

      list.counts[[i]] = counts.subset
    }


    ### combine new tables
    randomized.counts = do.call(cbind, list.counts)
    randomized.counts = randomized.counts[,original.column.order]


    ### substitute the counts in the original object and return the latter
    DEprot.object@norm.counts = as.matrix(randomized.counts)
    DEprot.object@boxplot.norm =
      DEprot::plot.counts(DEprot.object = DEprot.object,
                          which.data = "norm",
                          violin.color = "purple") +
      ggtitle(label = DEprot.object@boxplot.norm$labels$title,
              subtitle = DEprot.object@boxplot.norm$labels$subtitle)


    return(DEprot.object)
  } ## END function
